import os, sys, ipdb, argparse, string, json
import numpy as np


def fileread(str,breakcode='[[BR]]'):
    fid = open(str,'r')
    a = fid.readlines()
    fid.close()
    return breakcode.join(a)


def getOpts(expt_name):
    opt = getDefaultOpts()
    opt['gt_path'] = 'sd_friendliness'
    opt['practice_good_path'] = 'practice_good_friendliness'
    opt['practice_bad_path'] = 'practice_bad_friendliness'
    opt['which_algs_paths'] = ['ours_friendliness']
    opt['practice_captions_path'] = 'practice_captions.json'
    opt['captions_path'] = 'captions.json'
    opt['Nimgs'] = 50
    opt['Nperhit'] = 15
    opt['Npractice'] = 5
    opt['Nhits'] = 2
    opt['ut_id'] = 'NA'
    opt['base_url'] = 'http://baymax.ri.cmu.edu:8001/outputs/tests/mturk/'
    opt['instructions_file'] = 'templates/friendliness/instructions_basic_identity.html'
    opt['short_instructions_file'] = 'templates/friendliness/short_instructions_identity.html'
    opt['consent_file'] = 'templates/friendliness/consent_basic.html'
    opt['use_vigilance'] = False
    opt['paired'] = True
    opt['im_height'] = 400
    opt['im_width'] = 400
    opt['expt_name'] = expt_name
    return opt


def getDefaultOpts():
    opt = {}
    opt['expt_name'] = 'unset'
    opt['which_algs_paths'] = 'unset'		 # paths to images generated by algoritms, e.g. {'my_alg','baseline_alg'}
    opt['vigilance_path'] = 'vigilance'	   # path to vigilance images
    opt['gt_path'] = 'gt'					 # path to gt images
    opt['Nimgs'] = 100						# number of images to test
    opt['Ntest'] = 60						# number of test images per HIT
    opt['Npractice'] = 10					 # number of practice trials per HIT
    opt['Nhits'] = 50				 # number of HITs per algorithm
    opt['vigilance_freq'] = 0.0			   # percent of trials that are vigilance tests
    opt['use_vigilance'] = False			   # include vigilance trials (obviously fake images to check that Turkers are paying attention)	
    opt['ut_id'] = 'unset'					# set this using http://uniqueturker.myleott.com/
    opt['base_url'] = 'unset'				 # url where images to test are accessible as "opt['base_url']/n.png", for integers n
    opt['instructions_file'] = 'instructions_basic.html'		# instructions appear at the beginning of the HIT
    opt['short_instructions_file'] = 'short_instructions_basic.html'  # short instructions are shown at the top of every trial
    opt['consent_file'] = 'consent_basic.html'			 # informed consent text appears the beginning of the HIT
    
    opt['paired'] = True					  # if True, then fake/n.jpg will be pitted against real/n.jpg; if false, fake/n.jpg will be pitted against real/m.jpg, for random n and m
    opt['filename'] = lambda x : f'{x}.jpg'
    return opt


def checkOpts(opt):
    if(opt['which_algs_paths']=='unset'):
        print('must provide a list of algorithms to test')
    # if(opt['ut_id']=='unset'):
    #     print('must set a unique id for this HIT using http://uniqueturker.myleott.com/')
    if(opt['base_url']=='unset'):
        print('must provide a url where test images are accessible')
    if(opt['instructions_file']=='unset'):
        print('must provide a file containing html formatted instructions to display once at start of experiment')
    if(opt['short_instructions_file']=='unset'):
        print('must provide a file containing html formatted instructions to display on each trial')
    if(opt['consent_file']=='unset'):
        print('must provide a file containing html formatted infromed consent test, display at start of experiment')


def mk_expt(args):
    expt_name = args.name
    opt = getOpts(expt_name)
    checkOpts(opt)
    os.makedirs(os.path.join(args.output_folder, "htmls"), exist_ok=True)
    
    assert opt['paired']
    assert len(opt['which_algs_paths'])==1

    # i get a total of HxN number of comparisons
    A = len(opt['which_algs_paths']) # = 1 
    H = opt['Nhits'] # number of hits
    I = opt['Nimgs'] # = 50 * 5
    N = opt['Nperhit'] # number of images per hit = 10
    P = opt['Npractice'] # number of practice trials per HIT 

    # make sure H*N = I
    which_alg = np.random.randint(A, size=H*N)

    # img_indices = np.arange(I)
    img_indices = []
    for i in range(I):
        for seed in range(5):
            img_indices.append(f"{i}_{seed}_")
    img_indices = np.array(img_indices)
    
    # shuffle the indices with a fixed seed
    np.random.seed(0)
    np.random.shuffle(img_indices)

    which_ind0 = which_ind1 = img_indices
    which_side = np.random.randint(2, size=H*N) # randomize left or right
    # vigilance = (np.random.rand(H*N) < opt['vigilance_freq']) * opt['use_vigilance']

    gt_side = []
    images_left = []
    images_right = []
    test_captions = json.load(open(opt['captions_path'], 'r'))
    practice_captions = json.load(open(opt['practice_captions_path'], 'r'))
    captions = []

    for (nn,data) in enumerate(zip(which_ind0,which_ind1,which_side)):     
        cur_which_ind0, cur_which_ind1, cur_which_side = data   
        # if practice
        index_in_hit = nn % N
        if index_in_hit < P:
            if(cur_which_side==0):
                gt_side.append('left')
                images_left.append(f"{opt['practice_good_path']}/{index_in_hit}.png")
                images_right.append(f"{opt['practice_bad_path']}/{index_in_hit}.png")
            else:
                gt_side.append('right')
                images_left.append(f"{opt['practice_bad_path']}/{index_in_hit}.png")
                images_right.append(f"{opt['practice_good_path']}/{index_in_hit}.png")
            caption = practice_captions[index_in_hit]
        else:
            cur_alg_name = opt['which_algs_paths'][0]
            if(cur_which_side==0):
                gt_side.append('left')
                images_left.append(('%s/'+opt['filename'](cur_which_ind0))%opt['gt_path'])
                images_right.append(('%s/'+opt['filename'](cur_which_ind1))%cur_alg_name)
            else:
                gt_side.append('right')
                images_left.append(('%s/'+opt['filename'](cur_which_ind0))%cur_alg_name)
                images_right.append(('%s/'+opt['filename'](cur_which_ind1))%opt['gt_path'])
            caption = test_captions[int(cur_which_ind0.split('_')[0])]
        
        captions.append(caption)
    
    gt_side = np.array(gt_side).reshape((H,N)) # our method
    images_left = np.array(images_left).reshape((H,N))
    images_right = np.array(images_right).reshape((H,N))
    captions = np.array(captions).reshape((H,N))

    # ipdb.set_trace()
    
    breakcode='[[BR]]'

    # make an HTML file for each HIT
    for HIT_IDX in range(H):
        html = fileread('src/mturk_scripts/templates/index_template.html', breakcode=breakcode)
        html = html.replace('{{UT_ID}}', opt['ut_id'])
        html = html.replace('{{BASE_URL}}', opt['base_url'])
        html = html.replace('{{INSTRUCTIONS}}', fileread(opt['instructions_file'], breakcode=breakcode))
        html = html.replace('{{SHORT_INSTRUCTIONS}}', fileread(opt['short_instructions_file'], breakcode=breakcode))
        html = html.replace('{{CAPTION}}', f"{HIT_IDX}")
        html = html.replace('{{CONSENT}}', fileread(opt['consent_file'], breakcode=breakcode))
        html = html.replace('{{IM_DIV_HEIGHT}}', '%i'%(50+2))
        html = html.replace('{{IM_DIV_WIDTH}}', '%i'%(opt['im_width']+2))
        html = html.replace('{{IM_HEIGHT}}', '%i'%(opt['im_height']))
        html = html.replace('{{IM_WIDTH}}', '%i'%(opt['im_width']))
        html = html.replace('{{N_PRACTICE}}', '%i'%(opt['Npractice']))
        html = html.replace('{{TOTAL_NUM_IMS}}', '%i'%(opt['Nperhit']))
        # ipdb.set_trace()
        s = (' ').join([f'sequence_helper("{gt_side[HIT_IDX][i]}","{images_left[HIT_IDX][i]}","{images_right[HIT_IDX][i]}", "{captions[HIT_IDX][i]}");\n' for i in range(opt['Nperhit'])]) 
        html = html.replace('{{SEQUENCE}}', s)
        s = (' ').join(['<input type="hidden" name="selection%d" id="selection%d" value="unset">\n'%(i,i) for i in range(opt['Nperhit'])])
        html = html.replace('{{SELECTION}}', s)
        
        with open(os.path.join(args.output_folder,f'htmls/index_{HIT_IDX}.html'),'w') as f:
            f.writelines(html.split(breakcode))


parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-n','--name', type=str, default='experiments name')
parser.add_argument('--output_folder', type=str)

args = parser.parse_args()
mk_expt(args)