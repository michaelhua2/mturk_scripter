import os, sys, ipdb, argparse, string, json
import numpy as np


def fileread(str,breakcode='[[BR]]'):
    fid = open(str,'r')
    a = fid.readlines()
    fid.close()
    return breakcode.join(a)


def getOpts(expt_name):
    opt = getDefaultOpts()
    opt['gt_path'] = 'ours'
    opt['practice_good_path'] = 'practice_good_friendliness'
    opt['practice_bad_path'] = 'practice_bad_friendliness'
    opt['which_algs_paths'] = ['sd21', 'dalton', 'jiabin']
    opt['practice_captions_path'] = 'practice_prompts.json'
    opt['captions_path'] = 'prompts.json'
    opt['practice_nouns_path'] = 'practice_nouns.json'
    opt['captions_nouns_path'] = 'nouns.json'
    opt['Nimgs'] = 900
    opt['Nperhit'] = 30
    opt['Npractice'] = 5
    opt['Nhits'] = 30
    opt['ut_id'] = 'NA'
    opt['base_url'] = 'https://michaelhua2.github.io/'
    opt['instructions_file'] = 'templates/friendliness/instructions_basic_identity.html'
    opt['short_instructions_file'] = 'templates/friendliness/short_instructions_identity.html'
    opt['consent_file'] = 'templates/friendliness/consent_basic.html'
    opt['use_vigilance'] = False
    opt['paired'] = True
    opt['im_height'] = 400
    opt['im_width'] = 400
    opt['expt_name'] = expt_name
    return opt


def getDefaultOpts():
    opt = {}
    opt['expt_name'] = 'unset'
    opt['which_algs_paths'] = 'unset'		 # paths to images generated by algoritms, e.g. {'my_alg','baseline_alg'}
    opt['vigilance_path'] = 'vigilance'	   # path to vigilance images
    opt['gt_path'] = 'gt'					 # path to gt images
    opt['Nimgs'] = 100						# number of images to test
    opt['Ntest'] = 60						# number of test images per HIT
    opt['Npractice'] = 10					 # number of practice trials per HIT
    opt['Nhits'] = 50				 # number of HITs per algorithm
    opt['vigilance_freq'] = 0.0			   # percent of trials that are vigilance tests
    opt['use_vigilance'] = False			   # include vigilance trials (obviously fake images to check that Turkers are paying attention)	
    opt['ut_id'] = 'unset'					# set this using http://uniqueturker.myleott.com/
    opt['base_url'] = 'unset'				 # url where images to test are accessible as "opt['base_url']/n.png", for integers n
    opt['instructions_file'] = 'instructions_basic.html'		# instructions appear at the beginning of the HIT
    opt['short_instructions_file'] = 'short_instructions_basic.html'  # short instructions are shown at the top of every trial
    opt['consent_file'] = 'consent_basic.html'			 # informed consent text appears the beginning of the HIT
    
    opt['paired'] = True					  # if True, then fake/n.jpg will be pitted against real/n.jpg; if false, fake/n.jpg will be pitted against real/m.jpg, for random n and m
    opt['filename'] = lambda x : f'{x}.jpg'
    return opt


def checkOpts(opt):
    if(opt['which_algs_paths']=='unset'):
        print('must provide a list of algorithms to test')
    # if(opt['ut_id']=='unset'):
    #     print('must set a unique id for this HIT using http://uniqueturker.myleott.com/')
    if(opt['base_url']=='unset'):
        print('must provide a url where test images are accessible')
    if(opt['instructions_file']=='unset'):
        print('must provide a file containing html formatted instructions to display once at start of experiment')
    if(opt['short_instructions_file']=='unset'):
        print('must provide a file containing html formatted instructions to display on each trial')
    if(opt['consent_file']=='unset'):
        print('must provide a file containing html formatted infromed consent test, display at start of experiment')


def mk_expt(args):
    expt_name = args.name
    opt = getOpts(expt_name)
    checkOpts(opt)
    os.makedirs(os.path.join(args.output_folder, "htmls"), exist_ok=True)
    
    assert opt['paired']
    # assert len(opt['which_algs_paths'])==1

    # i get a total of HxN number of comparisons
    A = len(opt['which_algs_paths']) # = 3 
    H = 30 # number of hits
    N = 30 # number of images per hit = 10
    P = 5 # number of practice trials per HIT 

    np.random.seed(0)

    # make sure H*N = I
    all_comparisons = []
    for i in range(50):
        for seed in range(5):
            for baseline_idx in range(A):
                all_comparisons.append((i, seed, baseline_idx))
    
    all_comparisons = np.array(all_comparisons)
    np.random.shuffle(all_comparisons)

    which_ind0 = which_ind1 = img_indices
    which_side = np.random.randint(2, size=(H, N)) # randomize left or right
    # vigilance = (np.random.rand(H*N) < opt['vigilance_freq']) * opt['use_vigilance']

    gt_side = []
    images_left_rgb = []
    images_right_rgb = []
    images_left_cvd = []
    images_right_cvd = []
    test_nouns = json.load(open(opt['captions_nouns_path'], 'r'))
    test_nouns = [noun['red'] for noun in test_nouns]
    practice_nouns = json.load(open(opt['practice_nouns_path'], 'r'))
    nouns = []
    for h in range(H):
        for n in range(N):
            # if practice
            index_in_hit = f"{i}_{seed}_"
            cur_which_side = which_side[h, n]
            if n < P:
                if(cur_which_side==0):
                    gt_side.append('left')
                    # show the same practice image regardless if colorblind or not
                    images_left_rgb.append(f"{opt['practice_good_path']}/{index_in_hit}.jpg")
                    images_right_rgb.append(f"{opt['practice_bad_path']}/{index_in_hit}.jpg")
                    images_left_cvd.append(f"{opt['practice_good_path']}/{index_in_hit}.jpg")
                    images_right_cvd.append(f"{opt['practice_bad_path']}/{index_in_hit}.jpg")
                else:
                    gt_side.append('right')
                    images_left_rgb.append(f"{opt['practice_bad_path']}/{index_in_hit}.jpg")
                    images_right_rgb.append(f"{opt['practice_good_path']}/{index_in_hit}.jpg")
                    images_left_cvd.append(f"{opt['practice_bad_path']}/{index_in_hit}.jpg")
                    images_right_cvd.append(f"{opt['practice_good_path']}/{index_in_hit}.jpg")
                noun = practice_nouns[index_in_hit]
            else:
                # main experiment
                idx, seed, cur_which_alg = all_comparisons[h * N + (n - P)]
                idx_seed = f"{idx}_{seed}_"
                cur_alg_name = opt['which_algs_paths'][cur_which_alg]
                # print(cur_alg_name)
                if(cur_which_side==0):
                    gt_side.append('left')
                    images_left_rgb.append(('%s/rgb/'+opt['filename'](idx_seed))%opt['gt_path'])
                    images_right_rgb.append(('%s/rgb/'+opt['filename'](idx_seed))%cur_alg_name)
                    images_left_cvd.append(('%s/cvd/'+opt['filename'](idx_seed))%opt['gt_path'])
                    images_right_cvd.append(('%s/cvd/'+opt['filename'](idx_seed))%cur_alg_name)
                else:
                    gt_side.append('right')
                    images_left_rgb.append(('%s/rgb/'+opt['filename'](idx_seed))%cur_alg_name)
                    images_right_rgb.append(('%s/rgb/'+opt['filename'](idx_seed))%opt['gt_path'])
                    images_left_cvd.append(('%s/cvd/'+opt['filename'](idx_seed))%cur_alg_name)
                    images_right_cvd.append(('%s/cvd/'+opt['filename'](idx_seed))%opt['gt_path'])
                noun = test_nouns[idx]
            
            nouns.append(noun)
    
    gt_side = np.array(gt_side).reshape((H,N)) # our method
    images_left_rgb = np.array(images_left_rgb).reshape((H,N))
    images_left_cvd = np.array(images_left_cvd).reshape((H,N))
    images_right_rgb = np.array(images_right_rgb).reshape((H,N))
    images_right_cvd = np.array(images_right_cvd).reshape((H,N))
    nouns = np.array(nouns).reshape((H,N))

    is_practice = "true" if P > 0 else "false"    
    breakcode='[[BR]]'

    # make an HTML file for each HIT
    for HIT_IDX in range(H):
        html = fileread('src/mturk_scripts/templates/index_template_friendliness.html', breakcode=breakcode)
        html = html.replace('{{UT_ID}}', opt['ut_id'])
        html = html.replace('{{BASE_URL}}', opt['base_url'])
        html = html.replace('{{INSTRUCTIONS}}', fileread(opt['instructions_file'], breakcode=breakcode))
        html = html.replace('{{NOUN}}', nouns[HIT_IDX][0])
        html = html.replace('{{CONSENT}}', fileread(opt['consent_file'], breakcode=breakcode))
        html = html.replace('{{IM_DIV_HEIGHT}}', '%i'%(50+2))
        html = html.replace('{{IM_DIV_WIDTH}}', '%i'%(opt['im_width']+2))
        html = html.replace('{{IM_HEIGHT}}', '%i'%(opt['im_height']))
        html = html.replace('{{IM_WIDTH}}', '%i'%(opt['im_width']))
        html = html.replace('{{N_PRACTICE}}', '%i'%(opt['Npractice']))
        html = html.replace('{{TOTAL_NUM_IMS}}', '%i'%(opt['Nperhit']))
        html = html.replace('{{IS_PRACTICE}}', is_practice)
        # ipdb.set_trace()
        s = (' ').join([f'sequence_helper("{gt_side[HIT_IDX][i]}","{images_left_rgb[HIT_IDX][i]}","{images_right_rgb[HIT_IDX][i]}", "{images_left_cvd[HIT_IDX][i]}", "{images_right_cvd[HIT_IDX][i]}", "{nouns[HIT_IDX][i]}");\n' for i in range(opt['Nperhit'])]) 
        html = html.replace('{{SEQUENCE}}', s)
        s = (' ').join(['<input type="hidden" name="selection%d" id="selection%d" value="unset">\n'%(i,i) for i in range(opt['Nperhit'])])
        html = html.replace('{{SELECTION}}', s)
        
        with open(os.path.join(args.output_folder,f'htmls/index_{HIT_IDX}.html'),'w') as f:
            f.writelines(html.split(breakcode))


parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-n','--name', type=str, default='experiments name')
parser.add_argument('--output_folder', type=str)

args = parser.parse_args()
mk_expt(args)